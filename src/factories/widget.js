angular.module('kendo.directives').factory('widgetFactory', ['utils', '$parse', function(utils, $parse) {

  // Gather the options from defaults and from attributes
  var gatherOptions = function($parse, scope, element, attrs, kendoWidget) {

    // TODO: add kendoDefaults value service and use it to get a base options object?
    // var options = kendoDefaults[kendoWidget];

    var dataSource, role = attrs[kendoWidget];

    // check the data-source attribute
    dataSource = scope.$eval(attrs.source);

    // get the base widget that we are working with there
    var roles = kendo.rolesFromNamespaces([]);
    var widget = roles[kendoWidget.substring(5).toLowerCase()];

    // make a deep clone of the options object passed to the directive, if any.
    var options = $.extend(true, {}, scope[role], {});

    // parse out the options with Kendo UI using the base widget as the lookup for options
    options = $.extend({}, kendo.parseOptions(element[0], widget.fn.options), options);

    // If no dataSource was provided, 
    if( !options.dataSource ) {
      // check to see if was passed as data-source
      if (dataSource) {
        options.dataSource = dataSource;
      }
      // Check if one was set in the element's data or in its ancestors.
      // this clobber data-source but somebody has to win.
      dataSource = element.inheritedData('$kendoDataSource');
      if( dataSource ) {
        options.dataSource = dataSource;
      }
    }

    // Add on-* event handlers to options.
    addEventHandlers($parse, options, scope, attrs);

    // TODO: invoke controller.decorateOptions to allow other directives (or directive extensions)
    //       to modify the options before they get bound. This would provide an extention point for directives
    //       that require special processing like compiling nodes generated by kendo so that angular data binding
    //       can happen in kendo widget templates for example.
    //controller.decorateOptions(options);

    return options;

  };

  // Create an event handler function for each on-* attribute on the element and add to dest.
  var addEventHandlers = function($parse, dest, scope, attrs) {
    var memo,
        eventHandlers = utils.reduce(attrs, function(memo, attValue, att) {
      var match = att.match(/^on(.+)/), eventName, fn;
      if( match ) {
        // Lowercase the first letter to match the event name kendo expects.
        eventName = match[1].charAt(0).toLowerCase() + match[1].slice(1);
        // Parse the expression.
        fn = $parse(attValue);
        // Add a kendo event listener to the memo.
        memo[eventName] = function(e) {
          // Make sure this gets invoked in the angularjs lifecycle.
          scope.$apply(function() {
            // Invoke the parsed expression with a kendoEvent local that the expression can use.
            fn(scope, {kendoEvent: e});
          });
        };
      }
      return memo;
    }, {});

    // mix the eventHandlers in the options object
    angular.extend(dest, eventHandlers);
  };

  // Create the kendo widget with gathered options
  var create = function($parse, scope, element, attrs, kendoWidget) {

    // Create the options object
    var options = gatherOptions($parse, scope, element, attrs, kendoWidget);

    // Bind the kendo widget to the element and return a reference to the widget.
    return element[kendoWidget](options).data(kendoWidget);
  };

  return {
    create: create
  };

}]);
